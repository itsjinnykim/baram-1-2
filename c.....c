#include <avr/io.h>
#include <util/delay.h>

#define MOTOR_LEFT_IN1  PB5  
#define MOTOR_LEFT_IN2  PB6  
#define MOTOR_LEFT_EN   PE3 

#define MOTOR_RIGHT_IN1 PB2 
#define MOTOR_RIGHT_IN2 PB3 
#define MOTOR_RIGHT_EN  PE4 

#define CAM_W 640
#define CAM_H 480
#define CAM_CENTER (CAM_W / 2)

#define speed_high 
#define speed_low
#define speed_stop 

#define approach_w // 다가오는 폭 
#define stop_w // 폭이 이거보다 크면 정지 
#define center_range // 중심에서 이 값의 픽셀만큼 벗어나면 걍 그대로. 방향 유지하는 최소한의 픽셀 

// 값 설정 여러 개 해보면서 결정하기 

int x=0, y=0, w=0, h=0;

void motor_init(void);
void left_motor(uint8_t direction, uint8_t speed);
void right_motor(uint8_t direction, uint8_t speed);
void motor_forward(uint8_t speed);
void motor_backward(uint8_t speed);
void motor_stop(void);
void read_serial(void);

void motor_init(void)
{
	DDRB |= (1<< MOTOR_LEFT_IN1) | (1<<MOTOR_LEFT_IN2) | (1<<MOTOR_RIGHT_IN1) | (1<< MOTOR_RIGHT_IN2);
	DDRE |= (1<<MOTOR_LEFT_EN) | (1<<MOTOR_RIGHT_EN);
	
	TCCR3A = (1<<COM3A1) | (1<< COM3B1) | (1<<WGM30);
	TCCR3B = (1<<WGM32) | (1<<CS31);
	
	PORTB &= ~((1<<MOTOR_LEFT_IN1) | (1<<MOTOR_LEFT_IN2) | (1<< MOTOR_RIGHT_IN1) | (1<< MOTOR_RIGHT_IN2));
	OCR3A = 0;
	OCR3B = 0; 
}
	

void left_motor(uint8_t direction, uint8_t speed)
{
	if (direction == 1)
	{
		PORTB |= (1<< MOTOR_LEFT_IN1);
		PORTB &= ~(1<<MOTOR_LEFT_IN2);
	}
	else
	{
		PORTB &= ~(1<<MOTOR_LEFT_IN1);
		PORTB |= (1<< MOTOR_LEFT_IN2);
	}
	OCR3A = speed; 
}

void right_motor(uint8_t direction, uint8_t speed)
{
	if (direction == 1) 
	{ 
		PORTB |= (1 << MOTOR_RIGHT_IN1);
		PORTB &= ~(1 << MOTOR_RIGHT_IN2);
	} 
	else
	{ 
		PORTB &= ~(1 << MOTOR_RIGHT_IN1);
		PORTB |= (1 << MOTOR_RIGHT_IN2);
	}
	OCR3B = speed;
}

void motor_forward(uint8_t speed)
{
	left_motor(1, speed);
	right_motor(1, speed);
}

void motor_backward(uint8_t speed)
{
	left_motor(0, speed);
	right_motor(0, speed);
}

void motor_stop(void)
{
	OCR3A = 0;
	OCR3B =0;
	PORTB &= ~((1 << MOTOR_LEFT_IN1) | (1 << MOTOR_LEFT_IN2) |
	(1 << MOTOR_RIGHT_IN1) | (1 << MOTOR_RIGHT_IN2));
}

void read_serial(void)
{
	function read_serial():
	// 1. 버퍼와 인덱스 준비
	static buffer[32]         // 들어오는 문자열을 임시 저장
	static index = 0          // 지금 몇 번째 글자까지 저장했는지 표시
	
	// 2. UART에서 한 글자 받기
	char c = uart_receive()   // (예: '1', '2', '0', ',', '2', '4', ...)

	// 3. 줄바꿈 문자가 오면 한 줄 완성
	if c == '\n':
	buffer[index] = '\0'  // 문자열 끝 표시 (C 문자열 완성)
	
	// 4. 쉼표(,) 기준으로 문자열 자르기
	token1 = strtok(buffer, ",")   // 첫 번째 값 → "120"
	token2 = strtok(NULL, ",")     // 두 번째 값 → "240"
	token3 = strtok(NULL, ",")     // 세 번째 값 → "50"
	token4 = strtok(NULL, ",")     // 네 번째 값 → "60"
	
	// 5. 문자열 → 정수 변환
	x = atoi(token1)   // x = 120
	y = atoi(token2)   // y = 240
	w = atoi(token3)   // w = 50
	h = atoi(token4)   // h = 60
	
	// 6. 다음 메시지 준비
	index = 0
	
	// 7. 줄바꿈이 아닌 경우 → 버퍼에 저장
	else:
	buffer[index] = c
	index = index + 1
}

int main(void)
{
	motor_init();
	
	while(1)
	{
		if(w>stop_w)
		{
			모터 멈추거나 모터 후진 함수 호출
		}
		else if(w>approach_w)
		{
			if(cx>screen center right){
				우회전 
			}
			else if(cx<screen center left){
				좌회전 
		    }
			else{
				낮은 속도로 직진 
			}
	    }
	   else//물체가 멀리 있으면 
	   {
		   if (cx > SCREEN_CENTER_RIGHT): 우회전

		   else if (cx < SCREEN_CENTER_LEFT): 좌회전
	   }
   }